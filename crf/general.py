"""
This module implements graph cuts based inference algorithms for Pairwise CRF
model.

Yujia Li, 08/2013
"""

import numpy as np
import pygco

SMALL_CONSTANT = 1e-10

def unary_predict(unary):
    """
    Predict labels from given unaries.

    unary: a list of N unary potential matrices, each of size M*K where K is 
        the number of classes

    Return: N*M matrix, each row is an image, each element range from 0 to K-1
    """
    n_imgs = len(unary)
    n_pix = unary[0].shape[0]

    y = np.empty((n_imgs, n_pix), dtype=np.int)
    for i in range(n_imgs):
        y[i] = unary[i].argmin(axis=1)

    return y

def unary_pairwise_predict_single_image(unary, edges, edge_weights, pw_weight):
    """
    Run graph cuts to make predictions for segmentation of a single image.
    The pairwise model is a Potts model.

    unary: N*K, N is the number of pixels, K is the number of classes
    edges, edge_weights: pairwise potentials generated by one of the get_pw 
        functions, or in the same format.
    pw_weight: a parameter for relative importance of pairwise potentials
        compared to unary potentials.

    return: y, a N-d label vector
    """
    return pygco.cut_general_graph(edges, edge_weights, unary, 
            pw_weight * (1 - np.eye(2)), n_iter=-1, algorithm='expansion')

def unary_pairwise_predict(unary, pw, pw_weight):
    """
    Predict segmentation labels using unary and pairwise potentials for a list
    of images.

    unary: a list of N unary potential matrices
    pw: a list of N pairwise potential tuples

    pw_weight: a parameter for relative importance of pairwise potentials
        compared to unary potentials

    return: y, N*P matrix, P is the number of pixels in each image.
    """
    n_imgs = len(unary)
    n_pix = unary[0].shape[0]

    y = np.empty((n_imgs, n_pix), dtype=np.int)
    for i in range(n_imgs):
        y[i] = unary_pairwise_predict_single_image(unary[i], pw[i][0], 
                pw[i][1], pw_weight)
    
    return y

def unary_pairwise_rbm_predict(unary, pw, pw_weight, rbm, rbm_weight, n_iter=-1):
    """
    Predict segmentation labels using unary and pairwise potentials and a RBM
    high order potential or prior for a list of images. The EM algorithm
    described in our CVPR'13 paper is used for inference.

    unary: a list of N unary potential matrices
    pw: a listo f N pairwise potential tuples
    pw_weight: a parameter for relative importance of pairwise potentials
        compared to unary potentials.
    rbm: a RBM model, which contains at least three attributes - W, b and c
    rbm_weight: a parameter for relative importance of the RBM model.
    n_iter: number of iterations. Set to -1 means run until convergence.

    return: y, N*P matrix, P is the number of pixels in each image.
    """
    n_imgs = len(unary)
    W = rbm.W
    b = rbm.b
    c = rbm.c

    y = unary_pairwise_predict(unary, pw, pw_weight)
    mask = np.ones(n_imgs) > 0

    it = 0
    while mask.sum() > 0:
        if n_iter >= 0 and it >= n_iter:
            break
        it += 1

        # go up and down for one step to get RBM biases for pixels
        h = 1 / (1 + np.exp(-c - y[mask].dot(W)))
        bias = b + h.dot(W.T)

        # update unary potentials with these biases
        new_u = []
        new_pw = []
        p = 0
        for i in range(n_imgs):
            if mask[i]:
                new_u.append(unary[i].copy())
                new_u[p][:,1] = new_u[p][:,1] - bias[p] * rbm_weight
                new_pw.append(pw[i])

                p += 1

        new_y = unary_pairwise_predict(new_u, new_pw, pw_weight)

        new_mask = (new_y != y[mask]).any(axis=1)

        y[mask] = new_y
        mask[mask] = new_mask

    return y

def pixel_accuracy(prediction, ground_truth):
    """
    Compute per pixel accuracy of a prediction.

    prediction: N*D matrix, predicted labels. Each row is an image.
    ground_truth: N*D matrix, ground truth labels.

    Return: a float acc.
    """
    return (prediction == ground_truth).mean()

def intersection_over_union(prediction, ground_truth):
    """
    Compute intersection over union of a prediction.

    prediction: N*D matrix, predicted labels. Each row is an image.
    ground_truth: N*D matrix, ground truth labels.

    Return a float iou.
    """
    return (np.logical_and(prediction, ground_truth).sum(axis=1) / \
            (np.logical_or(prediction, ground_truth).sum(axis=1) + SMALL_CONSTANT)).mean()
